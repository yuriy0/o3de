#pragma once

#include <Atom/Features/PBR/Lights/Lights.azsli>
#include <Atom/Features/PBR/Lights/Ibl.azsli>

PbrLightingOutput ForwardPassPS_Common(VSOutput IN, bool isFrontFace, out float depth, out float3 wsNormal_out)
{
    // ------- Tangents & Bitangets -------
    float3 tangents[UvSetCount] = { IN.m_tangent.xyz, IN.m_tangent.xyz };
    float3 bitangents[UvSetCount] = { IN.m_bitangent.xyz, IN.m_bitangent.xyz };

    if ((o_parallax_feature_enabled && !o_enableSubsurfaceScattering) || o_normal_useTexture || (o_clearCoat_enabled && o_clearCoat_normal_useTexture) || o_detail_normal_useTexture)
    {
        PrepareGeneratedTangent(IN.m_normal, IN.m_worldPosition, isFrontFace, IN.m_uv, UvSetCount, tangents, bitangents);
    }

    // ------- Depth & Parallax -------

    depth = IN.m_position.z;
    bool displacementIsClipped = false;

    Surface surface;
    surface.position = IN.m_worldPosition;

    // ------- Alpha & Clip -------

    float2 baseColorUv = IN.m_uv[MaterialSrg::m_baseColorMapUvIndex];
    float2 opacityUv = IN.m_uv[MaterialSrg::m_opacityMapUvIndex];
    float alpha = GetAlphaInputAndClip(MaterialSrg::m_baseColorMap, MaterialSrg::m_opacityMap, baseColorUv, opacityUv, MaterialSrg::m_sampler, MaterialSrg::m_opacityFactor, o_opacity_source, MaterialSrg::m_cutoutMipBias);

    if (o_opacity_mode == OpacityMode::Blended || o_opacity_mode == OpacityMode::TintedTransparent)
    {
        if (alpha <= MaterialSrg::m_oitClip)
        {
            clip(-1);
        }
    }

    // ------- Detail Layer Setup -------

    const float2 detailUv = IN.m_detailUv[MaterialSrg::m_detail_allMapsUvIndex];

    // When the detail maps and the detail blend mask are on the same UV, they both use the transformed detail UVs because they are 'attached' to each other
    const float2 detailBlendMaskUv = (MaterialSrg::m_detail_blendMask_uvIndex == MaterialSrg::m_detail_allMapsUvIndex) ?
        IN.m_detailUv[MaterialSrg::m_detail_blendMask_uvIndex] : 
        IN.m_uv[MaterialSrg::m_detail_blendMask_uvIndex];        

    const float detailLayerBlendFactor = GetDetailLayerBlendFactor(
        MaterialSrg::m_detail_blendMask_texture,
        MaterialSrg::m_sampler,
        detailBlendMaskUv,
        o_detail_blendMask_useTexture,
        MaterialSrg::m_detail_blendFactor);

    // ------- Normal -------
    
    float2 normalUv = IN.m_uv[MaterialSrg::m_normalMapUvIndex];
    float3x3 uvMatrix = MaterialSrg::m_normalMapUvIndex == 0 ? MaterialSrg::m_uvMatrix : CreateIdentity3x3(); // By design, only UV0 is allowed to apply transforms.
    float detailLayerNormalFactor = MaterialSrg::m_detail_normal_factor * detailLayerBlendFactor;

    surface.normal = GetDetailedNormalInputWS(
        isFrontFace, IN.m_normal,
        tangents[MaterialSrg::m_normalMapUvIndex],      bitangents[MaterialSrg::m_normalMapUvIndex],      MaterialSrg::m_normalMap,             MaterialSrg::m_sampler, normalUv, MaterialSrg::m_normalFactor,  MaterialSrg::m_flipNormalX,         MaterialSrg::m_flipNormalY,         uvMatrix,                      o_normal_useTexture,
        tangents[MaterialSrg::m_detail_allMapsUvIndex], bitangents[MaterialSrg::m_detail_allMapsUvIndex], MaterialSrg::m_detail_normal_texture, MaterialSrg::m_sampler, detailUv, detailLayerNormalFactor,      MaterialSrg::m_detail_normal_flipX, MaterialSrg::m_detail_normal_flipY, MaterialSrg::m_detailUvMatrix, o_detail_normal_useTexture);

    wsNormal_out = surface.normal;

    //--------------------- Base Color ----------------------

    // [GFX TODO][ATOM-1761] Figure out how we want our base material to expect channels to be encoded, and apply that to the way we pack alpha. 
    
    float detailLayerBaseColorFactor = MaterialSrg::m_detail_baseColor_factor * detailLayerBlendFactor;

    float3 baseColor = GetDetailedBaseColorInput(
        MaterialSrg::m_baseColorMap,             MaterialSrg::m_sampler, baseColorUv, o_baseColor_useTexture,        MaterialSrg::m_baseColor,  MaterialSrg::m_baseColorFactor, o_baseColorTextureBlendMode,
        MaterialSrg::m_detail_baseColor_texture, MaterialSrg::m_sampler, detailUv,    o_detail_baseColor_useTexture, detailLayerBaseColorFactor);
        
    if(o_parallax_highlightClipping && displacementIsClipped)
    {
        ApplyParallaxClippingHighlight(baseColor);
    }

    // ------- Specular -------

    float2 specularUv = IN.m_uv[MaterialSrg::m_specularF0MapUvIndex];
    float specularF0Factor = GetSpecularInput(MaterialSrg::m_specularF0Map, MaterialSrg::m_sampler, specularUv, MaterialSrg::m_specularF0Factor, o_specularF0_useTexture);

    float metallic = 0;
    surface.SetAlbedoAndSpecularF0(baseColor, specularF0Factor, metallic);

    // ------- Roughness -------

    float2 roughnessUv = IN.m_uv[MaterialSrg::m_roughnessMapUvIndex];
    surface.roughnessLinear = GetRoughnessInput(MaterialSrg::m_roughnessMap, MaterialSrg::m_sampler, roughnessUv, MaterialSrg::m_roughnessFactor,
                                        MaterialSrg::m_roughnessLowerBound, MaterialSrg::m_roughnessUpperBound, o_roughness_useTexture);
    surface.CalculateRoughnessA();

    // ------- Transmission -------

    float2 transmissionUv = IN.m_uv[MaterialSrg::m_transmissionThicknessMapUvIndex];
    float4 transmissionTintThickness = GeTransmissionInput(MaterialSrg::m_transmissionThicknessMap, MaterialSrg::m_sampler, transmissionUv, MaterialSrg::m_transmissionTintThickness);
    surface.transmission.tint = transmissionTintThickness.rgb;
    surface.transmission.thickness = transmissionTintThickness.w;
    surface.transmission.transmissionParams = MaterialSrg::m_transmissionParams;

    // ------- Anisotropy -------

    if (o_enableAnisotropy)
    {
        // Convert the angle from [0..1] = [0 .. 180 degrees] to radians [0 .. PI]
        const float anisotropyAngle = MaterialSrg::m_anisotropicAngle * PI;
        const float anisotropyFactor = MaterialSrg::m_anisotropicFactor;
        surface.anisotropy.Init(surface.normal, IN.m_tangent, IN.m_bitangent, anisotropyAngle, anisotropyFactor, surface.roughnessA);
    }

    // ------- Lighting Data -------

    LightingData lightingData;

    // Light iterator
    lightingData.tileIterator.Init(IN.m_position, PassSrg::m_lightListRemapped, PassSrg::m_tileLightData);
    lightingData.Init(surface.position, surface.normal, surface.roughnessLinear);
    
    // Directional light shadow coordinates
    lightingData.shadowCoords = IN.m_shadowCoords;

    // ------- Occlusion -------
    
    lightingData.diffuseAmbientOcclusion = GetOcclusionInput(MaterialSrg::m_diffuseOcclusionMap, MaterialSrg::m_sampler, IN.m_uv[MaterialSrg::m_diffuseOcclusionMapUvIndex], MaterialSrg::m_diffuseOcclusionFactor, o_diffuseOcclusion_useTexture);
    lightingData.specularOcclusion = GetOcclusionInput(MaterialSrg::m_specularOcclusionMap, MaterialSrg::m_sampler, IN.m_uv[MaterialSrg::m_specularOcclusionMapUvIndex], MaterialSrg::m_specularOcclusionFactor, o_specularOcclusion_useTexture);

    // ------- Diffuse and Specular -------
    
    surface.clearCoat.factor = 0.0f;
    surface.clearCoat.roughness = 0.0f;
    surface.clearCoat.normal = float3(0.0f, 0.0f, 0.0f);

    // Diffuse and Specular response (used in IBL calculations)
    lightingData.specularResponse = FresnelSchlickWithRoughness(lightingData.NdotV, surface.specularF0, surface.roughnessLinear);
    lightingData.diffuseResponse = 1.0 - lightingData.specularResponse;

    // ------- Multiscatter -------

    lightingData.CalculateMultiscatterCompensation(surface.specularF0, o_specularF0_enableMultiScatterCompensation);

    // ------- Lighting Calculation -------

    // Apply Decals
    ApplyDecals(lightingData.tileIterator, surface);

    // Apply Direct Lighting
    ApplyDirectLighting(surface, lightingData);

    // Apply Image Based Lighting (IBL)
    ApplyIBL(surface, lightingData);

    // Finalize Lighting
    lightingData.FinalizeLighting(surface.transmission.tint);

    if (o_opacity_mode == OpacityMode::Blended || o_opacity_mode == OpacityMode::TintedTransparent)
    {
        alpha = FresnelSchlickWithRoughness(lightingData.NdotV, alpha, surface.roughnessLinear).x; // Increase opacity at grazing angles.
    }

    PbrLightingOutput lightingOutput = GetPbrLightingOutput(surface, lightingData, alpha);

    // ------- Opacity -------

    // Note: lightingOutput rendertargets are not always used as named, particularly m_diffuseColor (target 0) and
    // m_specularColor (target 1). Comments below describe the differences when appropriate.

    if (o_opacity_mode == OpacityMode::Blended || o_opacity_mode == OpacityMode::TintedTransparent)
    {
		// Handled further down in transparent pass
    }
    else
    {
        // Disable Subsurface scattering
        lightingOutput.m_diffuseColor.w = -1.0;
    }

    return lightingOutput;
}
